;;; hoagie-pages.el --- Little page-related functions -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Sebastián Monía
;;
;; Author: Sebastián Monía <sebastian@sebasmonia.com>
;; URL: https://git.sr.ht/~sebasmonia/dotfiles
;; Keywords: local text

;; This file is not part of GNU Emacs.

;;; Commentary:
;; Yet again, copying an existing Emacs feature and making my own version, like
;; I did with insert/removing pairs. In this case, it is `page-ext'.
;;
;; The base commands to move to throught the pages are good enough ("C-x [" and
;; "C-x ]"), even more so with `repeat' enabled.
;; And page-ext has an obsession with narrowing to page. Even if most of it can
;; be turned off in the customization options, I also dislike how it changes
;; the C-x C-p binding to a keymap.
;;
;; That leaves the page listing (called "directory" in page-ext jargon) as the
;; only feature that I want. So, I made my own version.
;; The listing format is "inspired by" `occur', and I like it better.

;;; Code:

(defun hoagie-pages--list ()
  "Get the pages in the current buffer, ignoring narrowing.
Return a list of lists (marker page-title line total-lines)."
  (save-excursion
    (save-restriction
      (widen)
      (let (headers)
        (goto-char (point-min))
        (while (re-search-forward page-delimiter nil t)
          (skip-chars-forward " \t\n")
          (push (list (point-marker)
                      (buffer-substring-no-properties (point) (pos-eol))
                      (line-number-at-pos)
                      ;; ooops, internal funtion
                      (car (page--count-lines-page)))
                headers))
        (nreverse headers)))))

(defun hoagie-pages--next-other-window ()
  "Move point to the next line, and open that page in a new window."
  (interactive)
  (next-line)
  (when (get-text-property (point) 'page-marker)
    (hoagie-pages--goto-return)))

(defun hoagie-pages--prev-other-window ()
  "Move point to the next line, and open that page in a new window."
  (interactive)
  (previous-line)
  (when (get-text-property (point) 'page-marker)
    (hoagie-pages--goto-return)))

(defun hoagie-pages--goto-return ()
  "Go to the page at point, then return to this buffer.
If another window is displayiing the targe buffer, use it. Else pop a
new window."
  (let* ((page-marker (get-text-property (point) 'page-marker))
         (page-buffer (marker-buffer page-marker))
         (win (get-buffer-window page-buffer))
         (me (get-buffer-window)))
    (if win
        (select-window win)
      (pop-to-buffer page-buffer))
    (goto-char page-marker)
    (select-window me)))

(defvar-keymap hoagie-list-pages-mode-map
  :doc "Keymap for buffers showing the pages of another buffer."
  "RET" #'hoagie-pages--goto
  "n" #'hoagie-pages--next-other-window
  "p" #'hoagie-pages--prev-other-window)

(define-derived-mode hoagie-list-pages-mode special-mode "List pages mode")

(defun hoagie-list-pages (&optional same-window)
  "Pop a buffer listin the pages of the current buffer.
Call with prefix arg SAME-WINDOW to re-use the same window."
  (interactive "P")
  ;; get all these values before changing to the output buffer
  (let ((pages (hoagie-pages--list))
        (target (buffer-name))
        (delimiter page-delimiter)
        (buf-name (format "*pages %s*" (buffer-name))))
    (with-current-buffer (get-buffer-create buf-name)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (format "%s pages in buffer %s (delimiter: \"%s\")"
                        (length pages) target delimiter))
        (add-text-properties (pos-bol) (pos-eol) '(face underline))
        (insert "\n")
        (setq pos-first-target (point))
        (dolist (elem pages)
          ;; harcoded max line width >_>
          (insert (format "%6s: " (nth 2 elem)))
          (add-text-properties (pos-bol) (point) '(face shadow))
          (insert (nth 1 elem))
          (insert (propertize (format " (%s lines)" (nth 3 elem))
                              'face 'shadow))
          (add-text-properties (pos-bol) (pos-eol)
                               `(page-marker ,(nth 0 elem)))
          (insert "\n"))
        (hoagie-list-pages-mode)
        (goto-char (point-min))))
    ;; Show the buffer in the current window:
    ;; -if jumping to another page, it happens in the same buffer
    ;; -if quitting (via "q"), then we go back to the original buffer
    (if same-window
        (switch-to-buffer buf-name)
      (pop-to-buffer buf-name))))

(defun hoagie-pages--goto ()
  "Go to the page at point.
Used from the list of pages generated by `hoagie-list-pages'."
  (interactive)
  ;; this should handle better the (uncommon, for me) scenario of "more than
  ;; one window is displaying the buffer".
  ;; The way it is now, it is oriented to "after using C-x C-p, switch this
  ;; window to the target buffer", and "after using C-u C-x C-p, move point in
  ;; the single, original window".
  (let* ((page-marker (get-text-property (point) 'page-marker))
         (page-buffer (marker-buffer page-marker))
         (win (get-buffer-window page-buffer)))
    (if win
        (select-window win)
      (switch-to-buffer page-buffer))
    (goto-char page-marker)))

(provide 'hoagie-pages)
;;; hoagie-pages.el ends here
